#!/usr/bin/env bash
set -e

# Source modular components
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/scripts/utils.sh"
source "$SCRIPT_DIR/scripts/config.sh"

# Main setup function
main() {
  print_status "Setting up Safe NixOS Configuration with nix-mox fragment system"
  echo

  # Check requirements
  check_root
  check_requirements

  # Get configuration directory
  local config_dir
  prompt_with_default "Enter the directory for your NixOS configuration" "$HOME/nixos-config" config_dir

  # Backup existing configuration if needed
  backup_existing_config "$config_dir"

  # Create directory structure
  create_directory_structure "$config_dir"

  # Get system configuration
  get_system_config
  select_display_manager
  select_desktop_environment
  select_graphics_driver
  configure_additional_features
  get_git_config

  # Generate configuration files
  print_status "Generating configuration files..."
  generate_configuration_files

  # Final instructions
  print_final_instructions
}

# Function to generate configuration files
generate_configuration_files() {
  # Generate flake.nix
  cat > flake.nix << EOF
{
  description = "Safe NixOS configuration with nix-mox fragment system";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    nix-mox.url = "github:hydepwns/nix-mox";
    home-manager = {
      url = "github:nix-community/home-manager";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = { self, nixpkgs, nix-mox, home-manager }: {
    nixosConfigurations.$hostname = nixpkgs.lib.nixosSystem {
      system = "x86_64-linux";
      modules = [
        ./nixos/configuration.nix
        ./hardware/hardware-configuration.nix
        home-manager.nixosModules.home-manager
        {
          home-manager.useGlobalPkgs = true;
          home-manager.useUserPackages = true;
          home-manager.users.$username = import ./home/home.nix;
        }
      ];
    };
  };
}
EOF

  # Generate configuration.nix
  cat > nixos/configuration.nix << EOF
{ config, lib, pkgs, ... }:

{
  imports = [
    ../hardware/hardware-configuration.nix
    ./fragments/base.nix
    ./fragments/display.nix
    ./fragments/graphics.nix
    ./fragments/security.nix
    ./fragments/development.nix
    ./fragments/gaming.nix
    ./fragments/messaging.nix
    ./fragments/video-calling.nix
    ./fragments/email.nix
  ];

  # Basic system configuration
  networking.hostName = "$hostname";
  time.timeZone = "$timezone";

  # User configuration
  users.users.$username = {
    isNormalUser = true;
    extraGroups = [ "wheel" "networkmanager" ];
    openssh.authorizedKeys.keys = [ "$ssh_key" ];
  };

  # Enable flakes
  nix.settings.experimental-features = [ "nix-command" "flakes" ];

  # System packages
  environment.systemPackages = with pkgs; [
    vim
    git
    wget
    curl
  ];

  # Enable OpenSSH daemon
  services.openssh.enable = $enable_ssh;

  # Enable firewall
  networking.firewall.enable = $enable_firewall;

  # This value determines the NixOS release from which the default
  # settings for stateful data, like file locations and database versions
  # on your system were taken. It's perfectly fine and recommended to leave
  # this value at the release version of the first install of this system.
  system.stateVersion = "23.11";
}
EOF

  # Generate hardware configuration
  cat > hardware/hardware-configuration.nix << EOF
# Do not modify this file!  It was generated by 'nixos-generate-config'
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports = [ (modulesPath + "/installer/scan/not-detected.nix") ];

  boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "usb_storage" "sd_mod" "rtsx_pci_sdmmc" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" ];
  boot.extraModulePackages = [ ];

  fileSystems."/" = {
    device = "/dev/disk/by-uuid/your-root-uuid";
    fsType = "ext4";
  };

  fileSystems."/boot" = {
    device = "/dev/disk/by-uuid/your-boot-uuid";
    fsType = "vfat";
  };

  swapDevices = [ ];

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.enp0s31f6.useDHCP = lib.mkDefault true;
  # networking.interfaces.wlp0s20f3.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
EOF

  # Generate home.nix
  cat > home/home.nix << EOF
{ config, lib, pkgs, ... }:

{
  home.username = "$username";
  home.homeDirectory = "/home/$username";

  # Git configuration
  programs.git = {
    enable = true;
    userName = "$git_user_name";
    userEmail = "$git_user_email";
  };

  # This value determines the Home Manager release that your
  # configuration is compatible with. This helps avoid breakage
  # when a new Home Manager release introduces backwards
  # incompatible changes.
  home.stateVersion = "23.11";

  # Let Home Manager install and manage itself.
  programs.home-manager.enable = true;
}
EOF

  print_success "Configuration files generated"
}

# Function to print final instructions
print_final_instructions() {
  echo
  print_success "Setup completed successfully!"
  echo
  print_status "Next steps:"
  echo "1. Review the generated configuration files"
  echo "2. Update hardware-configuration.nix with your actual disk UUIDs"
  echo "3. Customize the configuration as needed"
  echo "4. Run 'nixos-rebuild switch' to apply the configuration"
  echo
  print_status "Configuration files created:"
  echo "  - flake.nix"
  echo "  - nixos/configuration.nix"
  echo "  - hardware/hardware-configuration.nix"
  echo "  - home/home.nix"
  echo
  print_warning "Remember to backup your current configuration before applying changes!"
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
